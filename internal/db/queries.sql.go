// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const addProjectVS = `-- name: AddProjectVS :one
INSERT INTO project_vs (project_id, vs, note)
VALUES (?, ?, ?)
RETURNING id, project_id, vs, note, created_at
`

type AddProjectVSParams struct {
	ProjectID int64          `json:"project_id"`
	Vs        string         `json:"vs"`
	Note      sql.NullString `json:"note"`
}

func (q *Queries) AddProjectVS(ctx context.Context, arg AddProjectVSParams) (ProjectV, error) {
	row := q.db.QueryRowContext(ctx, addProjectVS, arg.ProjectID, arg.Vs, arg.Note)
	var i ProjectV
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Vs,
		&i.Note,
		&i.CreatedAt,
	)
	return i, err
}

const assignPayment = `-- name: AssignPayment :one
UPDATE payments SET
    user_id = ?,
    staff_comment = ?
WHERE id = ?
RETURNING id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason
`

type AssignPaymentParams struct {
	UserID       sql.NullInt64  `json:"user_id"`
	StaffComment sql.NullString `json:"staff_comment"`
	ID           int64          `json:"id"`
}

func (q *Queries) AssignPayment(ctx context.Context, arg AssignPaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, assignPayment, arg.UserID, arg.StaffComment, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
		&i.ProjectID,
		&i.DismissedAt,
		&i.DismissedBy,
		&i.DismissedReason,
	)
	return i, err
}

const countUsersByState = `-- name: CountUsersByState :many
SELECT state, COUNT(*) as count FROM users GROUP BY state
`

type CountUsersByStateRow struct {
	State string `json:"state"`
	Count int64  `json:"count"`
}

func (q *Queries) CountUsersByState(ctx context.Context) ([]CountUsersByStateRow, error) {
	rows, err := q.db.QueryContext(ctx, countUsersByState)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountUsersByStateRow{}
	for rows.Next() {
		var i CountUsersByStateRow
		if err := rows.Scan(&i.State, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createFee = `-- name: CreateFee :one
INSERT INTO fees (user_id, level_id, period_start, amount)
VALUES (?, ?, ?, ?)
RETURNING id, user_id, level_id, period_start, amount, created_at
`

type CreateFeeParams struct {
	UserID      int64     `json:"user_id"`
	LevelID     int64     `json:"level_id"`
	PeriodStart time.Time `json:"period_start"`
	Amount      string    `json:"amount"`
}

func (q *Queries) CreateFee(ctx context.Context, arg CreateFeeParams) (Fee, error) {
	row := q.db.QueryRowContext(ctx, createFee,
		arg.UserID,
		arg.LevelID,
		arg.PeriodStart,
		arg.Amount,
	)
	var i Fee
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LevelID,
		&i.PeriodStart,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const createLevel = `-- name: CreateLevel :one
INSERT INTO levels (name, amount, active)
VALUES (?, ?, ?)
RETURNING id, name, amount, active, created_at
`

type CreateLevelParams struct {
	Name   string `json:"name"`
	Amount string `json:"amount"`
	Active bool   `json:"active"`
}

func (q *Queries) CreateLevel(ctx context.Context, arg CreateLevelParams) (Level, error) {
	row := q.db.QueryRowContext(ctx, createLevel, arg.Name, arg.Amount, arg.Active)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Amount,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const createLog = `-- name: CreateLog :one
INSERT INTO system_logs (subsystem, level, user_id, message, metadata)
VALUES (?, ?, ?, ?, ?)
RETURNING id, subsystem, level, user_id, message, metadata, created_at
`

type CreateLogParams struct {
	Subsystem string         `json:"subsystem"`
	Level     string         `json:"level"`
	UserID    sql.NullInt64  `json:"user_id"`
	Message   string         `json:"message"`
	Metadata  sql.NullString `json:"metadata"`
}

func (q *Queries) CreateLog(ctx context.Context, arg CreateLogParams) (SystemLog, error) {
	row := q.db.QueryRowContext(ctx, createLog,
		arg.Subsystem,
		arg.Level,
		arg.UserID,
		arg.Message,
		arg.Metadata,
	)
	var i SystemLog
	err := row.Scan(
		&i.ID,
		&i.Subsystem,
		&i.Level,
		&i.UserID,
		&i.Message,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    user_id, date, amount, kind, kind_id,
    local_account, remote_account, identification, raw_data, staff_comment
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason
`

type CreatePaymentParams struct {
	UserID         sql.NullInt64  `json:"user_id"`
	Date           time.Time      `json:"date"`
	Amount         string         `json:"amount"`
	Kind           string         `json:"kind"`
	KindID         string         `json:"kind_id"`
	LocalAccount   string         `json:"local_account"`
	RemoteAccount  string         `json:"remote_account"`
	Identification string         `json:"identification"`
	RawData        sql.NullString `json:"raw_data"`
	StaffComment   sql.NullString `json:"staff_comment"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.UserID,
		arg.Date,
		arg.Amount,
		arg.Kind,
		arg.KindID,
		arg.LocalAccount,
		arg.RemoteAccount,
		arg.Identification,
		arg.RawData,
		arg.StaffComment,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
		&i.ProjectID,
		&i.DismissedAt,
		&i.DismissedBy,
		&i.DismissedReason,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (name, payments_id, description)
VALUES (?, ?, ?)
RETURNING id, name, payments_id, description
`

type CreateProjectParams struct {
	Name        string         `json:"name"`
	PaymentsID  sql.NullString `json:"payments_id"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createProject, arg.Name, arg.PaymentsID, arg.Description)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PaymentsID,
		&i.Description,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    keycloak_id, email, username, realname, phone, alt_contact,
    level_id, level_actual_amount, payments_id, state,
    is_council, is_staff
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type CreateUserParams struct {
	KeycloakID        sql.NullString `json:"keycloak_id"`
	Email             string         `json:"email"`
	Username          sql.NullString `json:"username"`
	Realname          sql.NullString `json:"realname"`
	Phone             sql.NullString `json:"phone"`
	AltContact        sql.NullString `json:"alt_contact"`
	LevelID           int64          `json:"level_id"`
	LevelActualAmount string         `json:"level_actual_amount"`
	PaymentsID        sql.NullString `json:"payments_id"`
	State             string         `json:"state"`
	IsCouncil         bool           `json:"is_council"`
	IsStaff           bool           `json:"is_staff"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.KeycloakID,
		arg.Email,
		arg.Username,
		arg.Realname,
		arg.Phone,
		arg.AltContact,
		arg.LevelID,
		arg.LevelActualAmount,
		arg.PaymentsID,
		arg.State,
		arg.IsCouncil,
		arg.IsStaff,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = ?
`

func (q *Queries) DeleteProject(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteProject, id)
	return err
}

const dismissPayment = `-- name: DismissPayment :one
UPDATE payments SET
    dismissed_at = CURRENT_TIMESTAMP,
    dismissed_by = ?,
    dismissed_reason = ?,
    staff_comment = ?
WHERE id = ?
RETURNING id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason
`

type DismissPaymentParams struct {
	DismissedBy     interface{}    `json:"dismissed_by"`
	DismissedReason interface{}    `json:"dismissed_reason"`
	StaffComment    sql.NullString `json:"staff_comment"`
	ID              int64          `json:"id"`
}

func (q *Queries) DismissPayment(ctx context.Context, arg DismissPaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, dismissPayment,
		arg.DismissedBy,
		arg.DismissedReason,
		arg.StaffComment,
		arg.ID,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
		&i.ProjectID,
		&i.DismissedAt,
		&i.DismissedBy,
		&i.DismissedReason,
	)
	return i, err
}

const getDistinctLevels = `-- name: GetDistinctLevels :many
SELECT DISTINCT level FROM system_logs ORDER BY level
`

func (q *Queries) GetDistinctLevels(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var level string
		if err := rows.Scan(&level); err != nil {
			return nil, err
		}
		items = append(items, level)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctSubsystems = `-- name: GetDistinctSubsystems :many
SELECT DISTINCT subsystem FROM system_logs ORDER BY subsystem
`

func (q *Queries) GetDistinctSubsystems(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDistinctSubsystems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var subsystem string
		if err := rows.Scan(&subsystem); err != nil {
			return nil, err
		}
		items = append(items, subsystem)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFee = `-- name: GetFee :one
SELECT id, user_id, level_id, period_start, amount, created_at FROM fees WHERE id = ? LIMIT 1
`

func (q *Queries) GetFee(ctx context.Context, id int64) (Fee, error) {
	row := q.db.QueryRowContext(ctx, getFee, id)
	var i Fee
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LevelID,
		&i.PeriodStart,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const getFeeByUserAndPeriod = `-- name: GetFeeByUserAndPeriod :one
SELECT id, user_id, level_id, period_start, amount, created_at FROM fees WHERE user_id = ? AND period_start = ? LIMIT 1
`

type GetFeeByUserAndPeriodParams struct {
	UserID      int64     `json:"user_id"`
	PeriodStart time.Time `json:"period_start"`
}

func (q *Queries) GetFeeByUserAndPeriod(ctx context.Context, arg GetFeeByUserAndPeriodParams) (Fee, error) {
	row := q.db.QueryRowContext(ctx, getFeeByUserAndPeriod, arg.UserID, arg.PeriodStart)
	var i Fee
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LevelID,
		&i.PeriodStart,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const getLevel = `-- name: GetLevel :one
SELECT id, name, amount, active, created_at FROM levels WHERE id = ? LIMIT 1
`

func (q *Queries) GetLevel(ctx context.Context, id int64) (Level, error) {
	row := q.db.QueryRowContext(ctx, getLevel, id)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Amount,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const getPayment = `-- name: GetPayment :one
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason FROM payments WHERE id = ? LIMIT 1
`

func (q *Queries) GetPayment(ctx context.Context, id int64) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPayment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
		&i.ProjectID,
		&i.DismissedAt,
		&i.DismissedBy,
		&i.DismissedReason,
	)
	return i, err
}

const getPaymentByKindAndID = `-- name: GetPaymentByKindAndID :one
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason FROM payments WHERE kind = ? AND kind_id = ? LIMIT 1
`

type GetPaymentByKindAndIDParams struct {
	Kind   string `json:"kind"`
	KindID string `json:"kind_id"`
}

func (q *Queries) GetPaymentByKindAndID(ctx context.Context, arg GetPaymentByKindAndIDParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPaymentByKindAndID, arg.Kind, arg.KindID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
		&i.ProjectID,
		&i.DismissedAt,
		&i.DismissedBy,
		&i.DismissedReason,
	)
	return i, err
}

const getProject = `-- name: GetProject :one
SELECT id, name, payments_id, description FROM projects WHERE id = ? LIMIT 1
`

func (q *Queries) GetProject(ctx context.Context, id int64) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PaymentsID,
		&i.Description,
	)
	return i, err
}

const getProjectBalance = `-- name: GetProjectBalance :one
SELECT COALESCE(SUM(CAST(amount AS REAL)), 0) as total
FROM (
    SELECT DISTINCT p.id, p.amount FROM payments p
    WHERE p.project_id = ?1
       OR p.identification IN (SELECT pv.vs FROM project_vs pv WHERE pv.project_id = ?1)
) sub
`

// Sum all payments for a project (by project_id OR by any VS in project_vs)
func (q *Queries) GetProjectBalance(ctx context.Context, projectID sql.NullInt64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getProjectBalance, projectID)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const getProjectByPaymentsID = `-- name: GetProjectByPaymentsID :one
SELECT p.id, p.name, p.payments_id, p.description FROM projects p
JOIN project_vs pv ON p.id = pv.project_id
WHERE pv.vs = ? LIMIT 1
`

// Find project by any of its VS identifiers (in project_vs table)
func (q *Queries) GetProjectByPaymentsID(ctx context.Context, vs string) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByPaymentsID, vs)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PaymentsID,
		&i.Description,
	)
	return i, err
}

const getProjectPayments = `-- name: GetProjectPayments :many
SELECT DISTINCT p.id, p.user_id, p.date, p.amount, p.kind, p.kind_id, p.local_account, p.remote_account, p.identification, p.raw_data, p.staff_comment, p.created_at, p.project_id, p.dismissed_at, p.dismissed_by, p.dismissed_reason FROM payments p
WHERE p.project_id = ?1
   OR p.identification IN (SELECT pv.vs FROM project_vs pv WHERE pv.project_id = ?1)
ORDER BY p.date DESC
`

// Get all payments for a project:
// 1. Payments explicitly assigned to project (project_id set)
// 2. Payments matching any of project's VS identifiers (from project_vs table)
func (q *Queries) GetProjectPayments(ctx context.Context, projectID sql.NullInt64) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, getProjectPayments, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Amount,
			&i.Kind,
			&i.KindID,
			&i.LocalAccount,
			&i.RemoteAccount,
			&i.Identification,
			&i.RawData,
			&i.StaffComment,
			&i.CreatedAt,
			&i.ProjectID,
			&i.DismissedAt,
			&i.DismissedBy,
			&i.DismissedReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectVSByVS = `-- name: GetProjectVSByVS :one
SELECT id, project_id, vs, note, created_at FROM project_vs WHERE vs = ? LIMIT 1
`

func (q *Queries) GetProjectVSByVS(ctx context.Context, vs string) (ProjectV, error) {
	row := q.db.QueryRowContext(ctx, getProjectVSByVS, vs)
	var i ProjectV
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Vs,
		&i.Note,
		&i.CreatedAt,
	)
	return i, err
}

const getUserBalance = `-- name: GetUserBalance :one
SELECT
    COALESCE((
        SELECT SUM(CAST(p.amount AS REAL))
        FROM payments p
        JOIN users u ON p.user_id = u.id
        WHERE p.user_id = ?
        AND p.identification = u.payments_id
    ), 0) -
    COALESCE((SELECT SUM(CAST(f.amount AS REAL)) FROM fees f WHERE f.user_id = ?), 0) as balance
`

type GetUserBalanceParams struct {
	UserID   sql.NullInt64 `json:"user_id"`
	UserID_2 int64         `json:"user_id_2"`
}

// Calculate membership fee balance (only payments matching user's payments_id VS)
func (q *Queries) GetUserBalance(ctx context.Context, arg GetUserBalanceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserBalance, arg.UserID, arg.UserID_2)
	var balance int64
	err := row.Scan(&balance)
	return balance, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByKeycloakID = `-- name: GetUserByKeycloakID :one
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users WHERE keycloak_id = ? LIMIT 1
`

func (q *Queries) GetUserByKeycloakID(ctx context.Context, keycloakID sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByKeycloakID, keycloakID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByPaymentsID = `-- name: GetUserByPaymentsID :one
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users WHERE payments_id = ? LIMIT 1
`

func (q *Queries) GetUserByPaymentsID(ctx context.Context, paymentsID sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByPaymentsID, paymentsID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const linkKeycloakID = `-- name: LinkKeycloakID :one
UPDATE users SET
    keycloak_id = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE email = ? AND keycloak_id IS NULL
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type LinkKeycloakIDParams struct {
	KeycloakID sql.NullString `json:"keycloak_id"`
	Email      string         `json:"email"`
}

func (q *Queries) LinkKeycloakID(ctx context.Context, arg LinkKeycloakIDParams) (User, error) {
	row := q.db.QueryRowContext(ctx, linkKeycloakID, arg.KeycloakID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAcceptedUsersForFees = `-- name: ListAcceptedUsersForFees :many
SELECT u.id, u.keycloak_id, u.email, u.username, u.realname, u.phone, u.alt_contact, u.level_id, u.level_actual_amount, u.payments_id, u.date_joined, u.keys_granted, u.keys_returned, u.state, u.is_council, u.is_staff, u.created_at, u.updated_at, l.amount as level_amount
FROM users u
JOIN levels l ON u.level_id = l.id
WHERE u.state = 'accepted'
ORDER BY u.id
`

type ListAcceptedUsersForFeesRow struct {
	ID                int64          `json:"id"`
	KeycloakID        sql.NullString `json:"keycloak_id"`
	Email             string         `json:"email"`
	Username          sql.NullString `json:"username"`
	Realname          sql.NullString `json:"realname"`
	Phone             sql.NullString `json:"phone"`
	AltContact        sql.NullString `json:"alt_contact"`
	LevelID           int64          `json:"level_id"`
	LevelActualAmount string         `json:"level_actual_amount"`
	PaymentsID        sql.NullString `json:"payments_id"`
	DateJoined        time.Time      `json:"date_joined"`
	KeysGranted       sql.NullTime   `json:"keys_granted"`
	KeysReturned      sql.NullTime   `json:"keys_returned"`
	State             string         `json:"state"`
	IsCouncil         bool           `json:"is_council"`
	IsStaff           bool           `json:"is_staff"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	LevelAmount       string         `json:"level_amount"`
}

func (q *Queries) ListAcceptedUsersForFees(ctx context.Context) ([]ListAcceptedUsersForFeesRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcceptedUsersForFees)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAcceptedUsersForFeesRow{}
	for rows.Next() {
		var i ListAcceptedUsersForFeesRow
		if err := rows.Scan(
			&i.ID,
			&i.KeycloakID,
			&i.Email,
			&i.Username,
			&i.Realname,
			&i.Phone,
			&i.AltContact,
			&i.LevelID,
			&i.LevelActualAmount,
			&i.PaymentsID,
			&i.DateJoined,
			&i.KeysGranted,
			&i.KeysReturned,
			&i.State,
			&i.IsCouncil,
			&i.IsStaff,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LevelAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllLevels = `-- name: ListAllLevels :many
SELECT id, name, amount, active, created_at FROM levels ORDER BY amount
`

func (q *Queries) ListAllLevels(ctx context.Context) ([]Level, error) {
	rows, err := q.db.QueryContext(ctx, listAllLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Level{}
	for rows.Next() {
		var i Level
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Amount,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDismissedPayments = `-- name: ListDismissedPayments :many
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason FROM payments WHERE dismissed_at IS NOT NULL ORDER BY dismissed_at DESC
`

func (q *Queries) ListDismissedPayments(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listDismissedPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Amount,
			&i.Kind,
			&i.KindID,
			&i.LocalAccount,
			&i.RemoteAccount,
			&i.Identification,
			&i.RawData,
			&i.StaffComment,
			&i.CreatedAt,
			&i.ProjectID,
			&i.DismissedAt,
			&i.DismissedBy,
			&i.DismissedReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeesByPeriod = `-- name: ListFeesByPeriod :many
SELECT id, user_id, level_id, period_start, amount, created_at FROM fees WHERE period_start = ? ORDER BY user_id
`

func (q *Queries) ListFeesByPeriod(ctx context.Context, periodStart time.Time) ([]Fee, error) {
	rows, err := q.db.QueryContext(ctx, listFeesByPeriod, periodStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Fee{}
	for rows.Next() {
		var i Fee
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LevelID,
			&i.PeriodStart,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeesByUser = `-- name: ListFeesByUser :many
SELECT id, user_id, level_id, period_start, amount, created_at FROM fees WHERE user_id = ? ORDER BY period_start DESC
`

func (q *Queries) ListFeesByUser(ctx context.Context, userID int64) ([]Fee, error) {
	rows, err := q.db.QueryContext(ctx, listFeesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Fee{}
	for rows.Next() {
		var i Fee
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LevelID,
			&i.PeriodStart,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLevels = `-- name: ListLevels :many
SELECT id, name, amount, active, created_at FROM levels WHERE active = TRUE ORDER BY amount
`

func (q *Queries) ListLevels(ctx context.Context) ([]Level, error) {
	rows, err := q.db.QueryContext(ctx, listLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Level{}
	for rows.Next() {
		var i Level
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Amount,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsBySubsystem = `-- name: ListLogsBySubsystem :many
SELECT id, subsystem, level, user_id, message, metadata, created_at FROM system_logs WHERE subsystem = ? ORDER BY created_at DESC LIMIT ?
`

type ListLogsBySubsystemParams struct {
	Subsystem string `json:"subsystem"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) ListLogsBySubsystem(ctx context.Context, arg ListLogsBySubsystemParams) ([]SystemLog, error) {
	rows, err := q.db.QueryContext(ctx, listLogsBySubsystem, arg.Subsystem, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SystemLog{}
	for rows.Next() {
		var i SystemLog
		if err := rows.Scan(
			&i.ID,
			&i.Subsystem,
			&i.Level,
			&i.UserID,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsByUser = `-- name: ListLogsByUser :many
SELECT id, subsystem, level, user_id, message, metadata, created_at FROM system_logs WHERE user_id = ? ORDER BY created_at DESC LIMIT ?
`

type ListLogsByUserParams struct {
	UserID sql.NullInt64 `json:"user_id"`
	Limit  int64         `json:"limit"`
}

func (q *Queries) ListLogsByUser(ctx context.Context, arg ListLogsByUserParams) ([]SystemLog, error) {
	rows, err := q.db.QueryContext(ctx, listLogsByUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SystemLog{}
	for rows.Next() {
		var i SystemLog
		if err := rows.Scan(
			&i.ID,
			&i.Subsystem,
			&i.Level,
			&i.UserID,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLogsFiltered = `-- name: ListLogsFiltered :many
SELECT id, subsystem, level, user_id, message, metadata, created_at FROM system_logs
WHERE (? = '' OR subsystem = ?)
  AND (? = '' OR level = ?)
  AND (? = 0 OR user_id = ?)
ORDER BY created_at DESC LIMIT ?
`

type ListLogsFilteredParams struct {
	Column1   interface{}   `json:"column_1"`
	Subsystem string        `json:"subsystem"`
	Column3   interface{}   `json:"column_3"`
	Level     string        `json:"level"`
	Column5   interface{}   `json:"column_5"`
	UserID    sql.NullInt64 `json:"user_id"`
	Limit     int64         `json:"limit"`
}

func (q *Queries) ListLogsFiltered(ctx context.Context, arg ListLogsFilteredParams) ([]SystemLog, error) {
	rows, err := q.db.QueryContext(ctx, listLogsFiltered,
		arg.Column1,
		arg.Subsystem,
		arg.Column3,
		arg.Level,
		arg.Column5,
		arg.UserID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SystemLog{}
	for rows.Next() {
		var i SystemLog
		if err := rows.Scan(
			&i.ID,
			&i.Subsystem,
			&i.Level,
			&i.UserID,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembershipPaymentsByUser = `-- name: ListMembershipPaymentsByUser :many
SELECT p.id, p.user_id, p.date, p.amount, p.kind, p.kind_id, p.local_account, p.remote_account, p.identification, p.raw_data, p.staff_comment, p.created_at, p.project_id, p.dismissed_at, p.dismissed_by, p.dismissed_reason
FROM payments p
JOIN users u ON p.user_id = u.id
WHERE p.user_id = ?
AND p.identification = u.payments_id
ORDER BY p.date DESC
`

// Only payments that match the user's membership VS (payments_id)
func (q *Queries) ListMembershipPaymentsByUser(ctx context.Context, userID sql.NullInt64) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listMembershipPaymentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Amount,
			&i.Kind,
			&i.KindID,
			&i.LocalAccount,
			&i.RemoteAccount,
			&i.Identification,
			&i.RawData,
			&i.StaffComment,
			&i.CreatedAt,
			&i.ProjectID,
			&i.DismissedAt,
			&i.DismissedBy,
			&i.DismissedReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByUser = `-- name: ListPaymentsByUser :many
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason FROM payments WHERE user_id = ? ORDER BY date DESC
`

func (q *Queries) ListPaymentsByUser(ctx context.Context, userID sql.NullInt64) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Amount,
			&i.Kind,
			&i.KindID,
			&i.LocalAccount,
			&i.RemoteAccount,
			&i.Identification,
			&i.RawData,
			&i.StaffComment,
			&i.CreatedAt,
			&i.ProjectID,
			&i.DismissedAt,
			&i.DismissedBy,
			&i.DismissedReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectVS = `-- name: ListProjectVS :many

SELECT id, project_id, vs, note, created_at FROM project_vs WHERE project_id = ? ORDER BY created_at
`

// ============================================================================
// PROJECT VS (Multiple VS identifiers per project)
// ============================================================================
func (q *Queries) ListProjectVS(ctx context.Context, projectID int64) ([]ProjectV, error) {
	rows, err := q.db.QueryContext(ctx, listProjectVS, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectV{}
	for rows.Next() {
		var i ProjectV
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Vs,
			&i.Note,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many

SELECT id, name, payments_id, description FROM projects ORDER BY id DESC
`

// ============================================================================
// PROJECTS (Fundraising / Special VS)
// ============================================================================
func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PaymentsID,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentLogs = `-- name: ListRecentLogs :many
SELECT id, subsystem, level, user_id, message, metadata, created_at FROM system_logs ORDER BY created_at DESC LIMIT ?
`

func (q *Queries) ListRecentLogs(ctx context.Context, limit int64) ([]SystemLog, error) {
	rows, err := q.db.QueryContext(ctx, listRecentLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SystemLog{}
	for rows.Next() {
		var i SystemLog
		if err := rows.Scan(
			&i.ID,
			&i.Subsystem,
			&i.Level,
			&i.UserID,
			&i.Message,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentPayments = `-- name: ListRecentPayments :many
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason FROM payments ORDER BY date DESC LIMIT ?
`

func (q *Queries) ListRecentPayments(ctx context.Context, limit int64) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listRecentPayments, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Amount,
			&i.Kind,
			&i.KindID,
			&i.LocalAccount,
			&i.RemoteAccount,
			&i.Identification,
			&i.RawData,
			&i.StaffComment,
			&i.CreatedAt,
			&i.ProjectID,
			&i.DismissedAt,
			&i.DismissedBy,
			&i.DismissedReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnassignedPayments = `-- name: ListUnassignedPayments :many
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason FROM payments WHERE user_id IS NULL AND dismissed_at IS NULL ORDER BY date DESC
`

func (q *Queries) ListUnassignedPayments(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listUnassignedPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Amount,
			&i.Kind,
			&i.KindID,
			&i.LocalAccount,
			&i.RemoteAccount,
			&i.Identification,
			&i.RawData,
			&i.StaffComment,
			&i.CreatedAt,
			&i.ProjectID,
			&i.DismissedAt,
			&i.DismissedBy,
			&i.DismissedReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users ORDER BY realname, email
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.KeycloakID,
			&i.Email,
			&i.Username,
			&i.Realname,
			&i.Phone,
			&i.AltContact,
			&i.LevelID,
			&i.LevelActualAmount,
			&i.PaymentsID,
			&i.DateJoined,
			&i.KeysGranted,
			&i.KeysReturned,
			&i.State,
			&i.IsCouncil,
			&i.IsStaff,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByState = `-- name: ListUsersByState :many
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users WHERE state = ? ORDER BY realname, email
`

func (q *Queries) ListUsersByState(ctx context.Context, state string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsersByState, state)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.KeycloakID,
			&i.Email,
			&i.Username,
			&i.Realname,
			&i.Phone,
			&i.AltContact,
			&i.LevelID,
			&i.LevelActualAmount,
			&i.PaymentsID,
			&i.DateJoined,
			&i.KeysGranted,
			&i.KeysReturned,
			&i.State,
			&i.IsCouncil,
			&i.IsStaff,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProjectVS = `-- name: RemoveProjectVS :exec
DELETE FROM project_vs WHERE project_id = ? AND vs = ?
`

type RemoveProjectVSParams struct {
	ProjectID int64  `json:"project_id"`
	Vs        string `json:"vs"`
}

func (q *Queries) RemoveProjectVS(ctx context.Context, arg RemoveProjectVSParams) error {
	_, err := q.db.ExecContext(ctx, removeProjectVS, arg.ProjectID, arg.Vs)
	return err
}

const undismissPayment = `-- name: UndismissPayment :one
UPDATE payments SET
    dismissed_at = NULL,
    dismissed_by = NULL,
    dismissed_reason = NULL
WHERE id = ?
RETURNING id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason
`

func (q *Queries) UndismissPayment(ctx context.Context, id int64) (Payment, error) {
	row := q.db.QueryRowContext(ctx, undismissPayment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
		&i.ProjectID,
		&i.DismissedAt,
		&i.DismissedBy,
		&i.DismissedReason,
	)
	return i, err
}

const updateLevel = `-- name: UpdateLevel :one
UPDATE levels SET
    name = ?,
    amount = ?,
    active = ?
WHERE id = ?
RETURNING id, name, amount, active, created_at
`

type UpdateLevelParams struct {
	Name   string `json:"name"`
	Amount string `json:"amount"`
	Active bool   `json:"active"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateLevel(ctx context.Context, arg UpdateLevelParams) (Level, error) {
	row := q.db.QueryRowContext(ctx, updateLevel,
		arg.Name,
		arg.Amount,
		arg.Active,
		arg.ID,
	)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Amount,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects SET
    name = ?,
    payments_id = ?,
    description = ?
WHERE id = ?
RETURNING id, name, payments_id, description
`

type UpdateProjectParams struct {
	Name        string         `json:"name"`
	PaymentsID  sql.NullString `json:"payments_id"`
	Description sql.NullString `json:"description"`
	ID          int64          `json:"id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProject,
		arg.Name,
		arg.PaymentsID,
		arg.Description,
		arg.ID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PaymentsID,
		&i.Description,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
    email = ?,
    username = ?,
    realname = ?,
    phone = ?,
    alt_contact = ?,
    level_id = ?,
    level_actual_amount = ?,
    payments_id = ?,
    state = ?,
    is_council = ?,
    is_staff = ?,
    keys_granted = ?,
    keys_returned = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type UpdateUserParams struct {
	Email             string         `json:"email"`
	Username          sql.NullString `json:"username"`
	Realname          sql.NullString `json:"realname"`
	Phone             sql.NullString `json:"phone"`
	AltContact        sql.NullString `json:"alt_contact"`
	LevelID           int64          `json:"level_id"`
	LevelActualAmount string         `json:"level_actual_amount"`
	PaymentsID        sql.NullString `json:"payments_id"`
	State             string         `json:"state"`
	IsCouncil         bool           `json:"is_council"`
	IsStaff           bool           `json:"is_staff"`
	KeysGranted       sql.NullTime   `json:"keys_granted"`
	KeysReturned      sql.NullTime   `json:"keys_returned"`
	ID                int64          `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Email,
		arg.Username,
		arg.Realname,
		arg.Phone,
		arg.AltContact,
		arg.LevelID,
		arg.LevelActualAmount,
		arg.PaymentsID,
		arg.State,
		arg.IsCouncil,
		arg.IsStaff,
		arg.KeysGranted,
		arg.KeysReturned,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserCustomFee = `-- name: UpdateUserCustomFee :one
UPDATE users SET
    level_actual_amount = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type UpdateUserCustomFeeParams struct {
	LevelActualAmount string `json:"level_actual_amount"`
	ID                int64  `json:"id"`
}

func (q *Queries) UpdateUserCustomFee(ctx context.Context, arg UpdateUserCustomFeeParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserCustomFee, arg.LevelActualAmount, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserKeycloakInfo = `-- name: UpdateUserKeycloakInfo :one
UPDATE users SET
    username = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type UpdateUserKeycloakInfoParams struct {
	Username sql.NullString `json:"username"`
	ID       int64          `json:"id"`
}

func (q *Queries) UpdateUserKeycloakInfo(ctx context.Context, arg UpdateUserKeycloakInfoParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserKeycloakInfo, arg.Username, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users SET
    realname = ?,
    phone = ?,
    alt_contact = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type UpdateUserProfileParams struct {
	Realname   sql.NullString `json:"realname"`
	Phone      sql.NullString `json:"phone"`
	AltContact sql.NullString `json:"alt_contact"`
	ID         int64          `json:"id"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserProfile,
		arg.Realname,
		arg.Phone,
		arg.AltContact,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertPayment = `-- name: UpsertPayment :one
INSERT INTO payments (
    user_id, project_id, date, amount, kind, kind_id,
    local_account, remote_account, identification, raw_data, staff_comment
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(kind, kind_id) DO UPDATE SET
    user_id = excluded.user_id,
    project_id = excluded.project_id,
    date = excluded.date,
    amount = excluded.amount,
    local_account = excluded.local_account,
    remote_account = excluded.remote_account,
    identification = excluded.identification,
    raw_data = excluded.raw_data,
    staff_comment = excluded.staff_comment
RETURNING id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at, project_id, dismissed_at, dismissed_by, dismissed_reason
`

type UpsertPaymentParams struct {
	UserID         sql.NullInt64  `json:"user_id"`
	ProjectID      sql.NullInt64  `json:"project_id"`
	Date           time.Time      `json:"date"`
	Amount         string         `json:"amount"`
	Kind           string         `json:"kind"`
	KindID         string         `json:"kind_id"`
	LocalAccount   string         `json:"local_account"`
	RemoteAccount  string         `json:"remote_account"`
	Identification string         `json:"identification"`
	RawData        sql.NullString `json:"raw_data"`
	StaffComment   sql.NullString `json:"staff_comment"`
}

func (q *Queries) UpsertPayment(ctx context.Context, arg UpsertPaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, upsertPayment,
		arg.UserID,
		arg.ProjectID,
		arg.Date,
		arg.Amount,
		arg.Kind,
		arg.KindID,
		arg.LocalAccount,
		arg.RemoteAccount,
		arg.Identification,
		arg.RawData,
		arg.StaffComment,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
		&i.ProjectID,
		&i.DismissedAt,
		&i.DismissedBy,
		&i.DismissedReason,
	)
	return i, err
}
