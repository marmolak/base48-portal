// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const assignPayment = `-- name: AssignPayment :one
UPDATE payments SET
    user_id = ?,
    staff_comment = ?
WHERE id = ?
RETURNING id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at
`

type AssignPaymentParams struct {
	UserID       sql.NullInt64  `json:"user_id"`
	StaffComment sql.NullString `json:"staff_comment"`
	ID           int64          `json:"id"`
}

func (q *Queries) AssignPayment(ctx context.Context, arg AssignPaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, assignPayment, arg.UserID, arg.StaffComment, arg.ID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
	)
	return i, err
}

const countUsersByState = `-- name: CountUsersByState :many
SELECT state, COUNT(*) as count FROM users GROUP BY state
`

type CountUsersByStateRow struct {
	State string `json:"state"`
	Count int64  `json:"count"`
}

func (q *Queries) CountUsersByState(ctx context.Context) ([]CountUsersByStateRow, error) {
	rows, err := q.db.QueryContext(ctx, countUsersByState)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountUsersByStateRow{}
	for rows.Next() {
		var i CountUsersByStateRow
		if err := rows.Scan(&i.State, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createFee = `-- name: CreateFee :one
INSERT INTO fees (user_id, level_id, period_start, amount)
VALUES (?, ?, ?, ?)
RETURNING id, user_id, level_id, period_start, amount, created_at
`

type CreateFeeParams struct {
	UserID      int64     `json:"user_id"`
	LevelID     int64     `json:"level_id"`
	PeriodStart time.Time `json:"period_start"`
	Amount      string    `json:"amount"`
}

func (q *Queries) CreateFee(ctx context.Context, arg CreateFeeParams) (Fee, error) {
	row := q.db.QueryRowContext(ctx, createFee,
		arg.UserID,
		arg.LevelID,
		arg.PeriodStart,
		arg.Amount,
	)
	var i Fee
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LevelID,
		&i.PeriodStart,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const createLevel = `-- name: CreateLevel :one
INSERT INTO levels (name, amount, active)
VALUES (?, ?, ?)
RETURNING id, name, amount, active, created_at
`

type CreateLevelParams struct {
	Name   string `json:"name"`
	Amount string `json:"amount"`
	Active bool   `json:"active"`
}

func (q *Queries) CreateLevel(ctx context.Context, arg CreateLevelParams) (Level, error) {
	row := q.db.QueryRowContext(ctx, createLevel, arg.Name, arg.Amount, arg.Active)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Amount,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (
    user_id, date, amount, kind, kind_id,
    local_account, remote_account, identification, raw_data, staff_comment
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at
`

type CreatePaymentParams struct {
	UserID         sql.NullInt64  `json:"user_id"`
	Date           time.Time      `json:"date"`
	Amount         string         `json:"amount"`
	Kind           string         `json:"kind"`
	KindID         string         `json:"kind_id"`
	LocalAccount   string         `json:"local_account"`
	RemoteAccount  string         `json:"remote_account"`
	Identification string         `json:"identification"`
	RawData        sql.NullString `json:"raw_data"`
	StaffComment   sql.NullString `json:"staff_comment"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, createPayment,
		arg.UserID,
		arg.Date,
		arg.Amount,
		arg.Kind,
		arg.KindID,
		arg.LocalAccount,
		arg.RemoteAccount,
		arg.Identification,
		arg.RawData,
		arg.StaffComment,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    keycloak_id, email, username, realname, phone, alt_contact,
    level_id, level_actual_amount, payments_id, state,
    is_council, is_staff
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type CreateUserParams struct {
	KeycloakID        sql.NullString `json:"keycloak_id"`
	Email             string         `json:"email"`
	Username          sql.NullString `json:"username"`
	Realname          sql.NullString `json:"realname"`
	Phone             sql.NullString `json:"phone"`
	AltContact        sql.NullString `json:"alt_contact"`
	LevelID           int64          `json:"level_id"`
	LevelActualAmount string         `json:"level_actual_amount"`
	PaymentsID        sql.NullString `json:"payments_id"`
	State             string         `json:"state"`
	IsCouncil         bool           `json:"is_council"`
	IsStaff           bool           `json:"is_staff"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.KeycloakID,
		arg.Email,
		arg.Username,
		arg.Realname,
		arg.Phone,
		arg.AltContact,
		arg.LevelID,
		arg.LevelActualAmount,
		arg.PaymentsID,
		arg.State,
		arg.IsCouncil,
		arg.IsStaff,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFee = `-- name: GetFee :one
SELECT id, user_id, level_id, period_start, amount, created_at FROM fees WHERE id = ? LIMIT 1
`

func (q *Queries) GetFee(ctx context.Context, id int64) (Fee, error) {
	row := q.db.QueryRowContext(ctx, getFee, id)
	var i Fee
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LevelID,
		&i.PeriodStart,
		&i.Amount,
		&i.CreatedAt,
	)
	return i, err
}

const getLevel = `-- name: GetLevel :one
SELECT id, name, amount, active, created_at FROM levels WHERE id = ? LIMIT 1
`

func (q *Queries) GetLevel(ctx context.Context, id int64) (Level, error) {
	row := q.db.QueryRowContext(ctx, getLevel, id)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Amount,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const getPayment = `-- name: GetPayment :one
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at FROM payments WHERE id = ? LIMIT 1
`

func (q *Queries) GetPayment(ctx context.Context, id int64) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPayment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
	)
	return i, err
}

const getPaymentByKindAndID = `-- name: GetPaymentByKindAndID :one
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at FROM payments WHERE kind = ? AND kind_id = ? LIMIT 1
`

type GetPaymentByKindAndIDParams struct {
	Kind   string `json:"kind"`
	KindID string `json:"kind_id"`
}

func (q *Queries) GetPaymentByKindAndID(ctx context.Context, arg GetPaymentByKindAndIDParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, getPaymentByKindAndID, arg.Kind, arg.KindID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
	)
	return i, err
}

const getUserBalance = `-- name: GetUserBalance :one
SELECT
    COALESCE((SELECT SUM(CAST(p.amount AS REAL)) FROM payments p WHERE p.user_id = ?), 0) -
    COALESCE((SELECT SUM(CAST(f.amount AS REAL)) FROM fees f WHERE f.user_id = ?), 0) as balance
`

type GetUserBalanceParams struct {
	UserID   sql.NullInt64 `json:"user_id"`
	UserID_2 int64         `json:"user_id_2"`
}

func (q *Queries) GetUserBalance(ctx context.Context, arg GetUserBalanceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserBalance, arg.UserID, arg.UserID_2)
	var balance int64
	err := row.Scan(&balance)
	return balance, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByKeycloakID = `-- name: GetUserByKeycloakID :one
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users WHERE keycloak_id = ? LIMIT 1
`

func (q *Queries) GetUserByKeycloakID(ctx context.Context, keycloakID sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByKeycloakID, keycloakID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByPaymentsID = `-- name: GetUserByPaymentsID :one
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users WHERE payments_id = ? LIMIT 1
`

func (q *Queries) GetUserByPaymentsID(ctx context.Context, paymentsID sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByPaymentsID, paymentsID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const linkKeycloakID = `-- name: LinkKeycloakID :one
UPDATE users SET
    keycloak_id = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE email = ? AND keycloak_id IS NULL
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type LinkKeycloakIDParams struct {
	KeycloakID sql.NullString `json:"keycloak_id"`
	Email      string         `json:"email"`
}

func (q *Queries) LinkKeycloakID(ctx context.Context, arg LinkKeycloakIDParams) (User, error) {
	row := q.db.QueryRowContext(ctx, linkKeycloakID, arg.KeycloakID, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllLevels = `-- name: ListAllLevels :many
SELECT id, name, amount, active, created_at FROM levels ORDER BY amount
`

func (q *Queries) ListAllLevels(ctx context.Context) ([]Level, error) {
	rows, err := q.db.QueryContext(ctx, listAllLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Level{}
	for rows.Next() {
		var i Level
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Amount,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeesByPeriod = `-- name: ListFeesByPeriod :many
SELECT id, user_id, level_id, period_start, amount, created_at FROM fees WHERE period_start = ? ORDER BY user_id
`

func (q *Queries) ListFeesByPeriod(ctx context.Context, periodStart time.Time) ([]Fee, error) {
	rows, err := q.db.QueryContext(ctx, listFeesByPeriod, periodStart)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Fee{}
	for rows.Next() {
		var i Fee
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LevelID,
			&i.PeriodStart,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeesByUser = `-- name: ListFeesByUser :many
SELECT id, user_id, level_id, period_start, amount, created_at FROM fees WHERE user_id = ? ORDER BY period_start DESC
`

func (q *Queries) ListFeesByUser(ctx context.Context, userID int64) ([]Fee, error) {
	rows, err := q.db.QueryContext(ctx, listFeesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Fee{}
	for rows.Next() {
		var i Fee
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LevelID,
			&i.PeriodStart,
			&i.Amount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLevels = `-- name: ListLevels :many
SELECT id, name, amount, active, created_at FROM levels WHERE active = TRUE ORDER BY amount
`

func (q *Queries) ListLevels(ctx context.Context) ([]Level, error) {
	rows, err := q.db.QueryContext(ctx, listLevels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Level{}
	for rows.Next() {
		var i Level
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Amount,
			&i.Active,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByUser = `-- name: ListPaymentsByUser :many
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at FROM payments WHERE user_id = ? ORDER BY date DESC
`

func (q *Queries) ListPaymentsByUser(ctx context.Context, userID sql.NullInt64) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listPaymentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Amount,
			&i.Kind,
			&i.KindID,
			&i.LocalAccount,
			&i.RemoteAccount,
			&i.Identification,
			&i.RawData,
			&i.StaffComment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentPayments = `-- name: ListRecentPayments :many
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at FROM payments ORDER BY date DESC LIMIT ?
`

func (q *Queries) ListRecentPayments(ctx context.Context, limit int64) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listRecentPayments, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Amount,
			&i.Kind,
			&i.KindID,
			&i.LocalAccount,
			&i.RemoteAccount,
			&i.Identification,
			&i.RawData,
			&i.StaffComment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnassignedPayments = `-- name: ListUnassignedPayments :many
SELECT id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at FROM payments WHERE user_id IS NULL ORDER BY date DESC
`

func (q *Queries) ListUnassignedPayments(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.QueryContext(ctx, listUnassignedPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Date,
			&i.Amount,
			&i.Kind,
			&i.KindID,
			&i.LocalAccount,
			&i.RemoteAccount,
			&i.Identification,
			&i.RawData,
			&i.StaffComment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users ORDER BY realname, email
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.KeycloakID,
			&i.Email,
			&i.Username,
			&i.Realname,
			&i.Phone,
			&i.AltContact,
			&i.LevelID,
			&i.LevelActualAmount,
			&i.PaymentsID,
			&i.DateJoined,
			&i.KeysGranted,
			&i.KeysReturned,
			&i.State,
			&i.IsCouncil,
			&i.IsStaff,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByState = `-- name: ListUsersByState :many
SELECT id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at FROM users WHERE state = ? ORDER BY realname, email
`

func (q *Queries) ListUsersByState(ctx context.Context, state string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsersByState, state)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.KeycloakID,
			&i.Email,
			&i.Username,
			&i.Realname,
			&i.Phone,
			&i.AltContact,
			&i.LevelID,
			&i.LevelActualAmount,
			&i.PaymentsID,
			&i.DateJoined,
			&i.KeysGranted,
			&i.KeysReturned,
			&i.State,
			&i.IsCouncil,
			&i.IsStaff,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLevel = `-- name: UpdateLevel :one
UPDATE levels SET
    name = ?,
    amount = ?,
    active = ?
WHERE id = ?
RETURNING id, name, amount, active, created_at
`

type UpdateLevelParams struct {
	Name   string `json:"name"`
	Amount string `json:"amount"`
	Active bool   `json:"active"`
	ID     int64  `json:"id"`
}

func (q *Queries) UpdateLevel(ctx context.Context, arg UpdateLevelParams) (Level, error) {
	row := q.db.QueryRowContext(ctx, updateLevel,
		arg.Name,
		arg.Amount,
		arg.Active,
		arg.ID,
	)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Amount,
		&i.Active,
		&i.CreatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
    email = ?,
    username = ?,
    realname = ?,
    phone = ?,
    alt_contact = ?,
    level_id = ?,
    level_actual_amount = ?,
    payments_id = ?,
    state = ?,
    is_council = ?,
    is_staff = ?,
    keys_granted = ?,
    keys_returned = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type UpdateUserParams struct {
	Email             string         `json:"email"`
	Username          sql.NullString `json:"username"`
	Realname          sql.NullString `json:"realname"`
	Phone             sql.NullString `json:"phone"`
	AltContact        sql.NullString `json:"alt_contact"`
	LevelID           int64          `json:"level_id"`
	LevelActualAmount string         `json:"level_actual_amount"`
	PaymentsID        sql.NullString `json:"payments_id"`
	State             string         `json:"state"`
	IsCouncil         bool           `json:"is_council"`
	IsStaff           bool           `json:"is_staff"`
	KeysGranted       sql.NullTime   `json:"keys_granted"`
	KeysReturned      sql.NullTime   `json:"keys_returned"`
	ID                int64          `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Email,
		arg.Username,
		arg.Realname,
		arg.Phone,
		arg.AltContact,
		arg.LevelID,
		arg.LevelActualAmount,
		arg.PaymentsID,
		arg.State,
		arg.IsCouncil,
		arg.IsStaff,
		arg.KeysGranted,
		arg.KeysReturned,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserKeycloakInfo = `-- name: UpdateUserKeycloakInfo :one
UPDATE users SET
    username = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type UpdateUserKeycloakInfoParams struct {
	Username sql.NullString `json:"username"`
	ID       int64          `json:"id"`
}

func (q *Queries) UpdateUserKeycloakInfo(ctx context.Context, arg UpdateUserKeycloakInfoParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserKeycloakInfo, arg.Username, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users SET
    username = ?,
    realname = ?,
    phone = ?,
    alt_contact = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, keycloak_id, email, username, realname, phone, alt_contact, level_id, level_actual_amount, payments_id, date_joined, keys_granted, keys_returned, state, is_council, is_staff, created_at, updated_at
`

type UpdateUserProfileParams struct {
	Username   sql.NullString `json:"username"`
	Realname   sql.NullString `json:"realname"`
	Phone      sql.NullString `json:"phone"`
	AltContact sql.NullString `json:"alt_contact"`
	ID         int64          `json:"id"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserProfile,
		arg.Username,
		arg.Realname,
		arg.Phone,
		arg.AltContact,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.KeycloakID,
		&i.Email,
		&i.Username,
		&i.Realname,
		&i.Phone,
		&i.AltContact,
		&i.LevelID,
		&i.LevelActualAmount,
		&i.PaymentsID,
		&i.DateJoined,
		&i.KeysGranted,
		&i.KeysReturned,
		&i.State,
		&i.IsCouncil,
		&i.IsStaff,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertPayment = `-- name: UpsertPayment :one
INSERT INTO payments (
    user_id, date, amount, kind, kind_id,
    local_account, remote_account, identification, raw_data, staff_comment
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(kind, kind_id) DO UPDATE SET
    date = excluded.date,
    amount = excluded.amount,
    local_account = excluded.local_account,
    remote_account = excluded.remote_account,
    identification = excluded.identification,
    raw_data = excluded.raw_data
RETURNING id, user_id, date, amount, kind, kind_id, local_account, remote_account, identification, raw_data, staff_comment, created_at
`

type UpsertPaymentParams struct {
	UserID         sql.NullInt64  `json:"user_id"`
	Date           time.Time      `json:"date"`
	Amount         string         `json:"amount"`
	Kind           string         `json:"kind"`
	KindID         string         `json:"kind_id"`
	LocalAccount   string         `json:"local_account"`
	RemoteAccount  string         `json:"remote_account"`
	Identification string         `json:"identification"`
	RawData        sql.NullString `json:"raw_data"`
	StaffComment   sql.NullString `json:"staff_comment"`
}

func (q *Queries) UpsertPayment(ctx context.Context, arg UpsertPaymentParams) (Payment, error) {
	row := q.db.QueryRowContext(ctx, upsertPayment,
		arg.UserID,
		arg.Date,
		arg.Amount,
		arg.Kind,
		arg.KindID,
		arg.LocalAccount,
		arg.RemoteAccount,
		arg.Identification,
		arg.RawData,
		arg.StaffComment,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Date,
		&i.Amount,
		&i.Kind,
		&i.KindID,
		&i.LocalAccount,
		&i.RemoteAccount,
		&i.Identification,
		&i.RawData,
		&i.StaffComment,
		&i.CreatedAt,
	)
	return i, err
}
